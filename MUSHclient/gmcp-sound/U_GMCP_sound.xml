<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Dienstag, Februar 06, 2018, 7:15  -->
<!-- MuClient version 4.94 -->
<!-- Plugin "GMCP_Sound" generated by Plugin Wizard -->

<muclient>

<plugin
   name="U_GMCP_sound"
   author="Myonara"
   id="be65a06308c74da35d4e1c5f"
   language="Lua"
   purpose="Handle GMCP messages and broadcast data/sounds for UNItopia"
   save_state="y"
   date_written="2018-02-06 19:13:42"
   requires="4.94"
   version="1.0"
   >
 <description trim="y">

UNItopia GMCP Handler.

Purpose is to receive incoming GMCP messages and populate the global
table 'gmcpdata' with the values as received so that GMCP under Mushclient
can use partial refreshes of data. Main focus is on sound.

Copied and Adapted from

   http://www.aardwolf.com/wiki/index.php/Clients/MushclientGMCP

</description>

</plugin>

<aliases>
  <alias
   script="gmcpdebug"
   match="^gmcpdebug (.*)?$"
   enabled="y"
   regexp="y"
   sequence="100"
   ignore_case="y"
  >
  </alias>

  <alias
   match="sendgmcp *"
   script="GMCP_Alias"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>

</aliases>

<!--  Get our standard constants -->

<script>
<![CDATA[

require "json"
require "serialize"
require "gmcphelper" -- identical to aardwolf!
require "soundcache" -- new from myonara@unitopia.de
require "tprint"

local IAC, SB, SE, DO = 0xFF, 0xFA, 0xF0, 0xFD
local GMCP      = 201
local GMCPDebug = 0

function gmcpdebug(name, line, wildcards)
  newval = tonumber(wildcards[1])
  if not newval or newval > 2 or newval < 0 then
    ColourNote("darkorange", "", "GMCPDebug valid values are: 0 - off, 1 - simple, 2 - verbose")
    return
  end
  GMCPDebug = newval
  local msg = "off"
  if GMCPDebug == 1 then
    msg = "simple"
  elseif GMCPDebug == 2 then
    msg = "verbose"
  end
  ColourNote ("darkorange", "", "GMCPDebug: " .. msg)
end

function GMCP_Alias(name, line, wildcards)
   if (wildcards[1] ~= nil) then
      Send_GMCP_Packet(wildcards[1]) -- in gmcphelper
   end
end 
 
---------------------------------------------------------------------------------------------------
-- Mushclient callback function when telnet SB data received.
---------------------------------------------------------------------------------------------------
function OnPluginTelnetSubnegotiation (msg_type, data)
   if msg_type ~= GMCP then
      return
   end -- if not GMCP
  
   if GMCPDebug > 0 then ColourNote ("darkorange", "", data) end

   message, params = string.match (data, "([%a.]+)%s+(.*)")
  
   if not message then
      return
   end -- if
  
   if not string.match (params, "^[%[{]") then
      params =  "[" .. params .. "]"  -- JSON hack, make msg first element of an array.
   end -- if 

   local t = json.decode (params)
  
   if type(t) == "table" then

      gmcpdata = gmcpdata or {}

      -- Create the higher level tables based on tag such as char.vitals or room.info etc.
      -- Lowest level of those wlil be the 'parent' for parse_gmcp
      local parent = gmcpdata
      for item in string.gmatch(message,"%a+") do

         -- reset room data hack, for now.
         if item == "room" or item == "comm" then parent[item] = nil end

         parent[item] = parent[item] or {}
         parent = parent[item]
      end
 
      parse_gmcp(t,nil,parent)

      if GMCPDebug > 1 then print ("gmcpdata serialized: " .. serialize.save_simple(gmcpdata)) end
 
      unitopia_messages(message) -- new
      BroadcastPlugin(1,message)

      -- Examples of use from here on. Can be uncommented for debug.
      --print("Testing room.info.exits table      : " .. gmcpval("room.info.exits")) -- serialized table.
      --print("Testing correct room name          : " .. gmcpval("room.info.brief")) -- single field
      --print("Testing character str stat         : " .. gmcpval("char.stats.str"))  -- single number.
      --print("Testing top-level value            : " .. gmcpval("char"))            -- all char table.
      --print("Testing bad top-level value        : " .. gmcpval("sdlkfsldf"))       -- nil (not error)
      --print("Testing bad lower level            : " .. gmcpval("blah.1.2.3"))      -- nil
      --print("Testing bad lower level inside good: " .. gmcpval("room.info.hinick")) -- nil
      --print("Testing north exit, deeper nest    : " .. gmcpval("room.info.exits.n"))
      -- End of test cases.
 
  end -- if
   
end -- function OnPluginTelnetSubnegotiation

function OnPluginInstall()
    BroadcastPlugin(1,"reload") -- reload basically tells other plugins "clear all your gmcp data"
end

function OnPluginTelnetRequest (msg_type, data)

  if msg_type == GMCP and data == "WILL" then
    return true
  end -- if
  
  if msg_type == GMCP and data == "SENT_DO" then
    Note ("Enabling GMCP.") 
    -- This hard-coded block may need to be made into a config table as we add more message types.
    Send_GMCP_Packet (string.format ('Core.Hello { "client": "MUSHclient", "version": "%s" }', Version ()))
    Send_GMCP_Packet ('Core.Supports.Set [ "Sound 1" ]')-- new
    -- Send_GMCP_Packet ('Core.Supports.Set [ "Char 1", "Comm 1", "Room 1" ]')
    return true
  end -- if GMCP login needed (just sent DO)
  
  return false

end -- function OnPluginTelnetRequest


---------------------------------------------------------------------------------------------------
-- FUNCTION:: init_gmcpdata
--    Performs 2 functions:
--       1. Define a table of tags we support, including refreshed tags (clear each time) and 
--          regular tags.
--       2. Initialize gmcpdata to have empty tables nested at these levels.
---------------------------------------------------------------------------------------------------
function init_gmcpdata()
    --- Not used yet, placeholder to replace room reset data hack with a table.
end -- init_gmcpdata

---------------------------------------------------------------------------------------------------
-- FUNCTION:: parse_gmcp
--   Receives a set of JSON data and a parent to store its table into. Will recursively call 
--   itself building up the levels of, for example, gmcpdata.room.info.exits.n as it goes.
---------------------------------------------------------------------------------------------------
function parse_gmcp(t, done, parent) 

   assert (t, "nil table passed to parse_gmcp")
   assert (parent, "nil parent passed to parse_gmcp")
   assert (type (t) == "table",  "non-table value passed to parse_gmcp")
   assert (type (parent) == "table", "non-table parent value passed to parse_gmcp")

   local function parseone(val)
      if type (val) == "string" then
         return val 
      elseif type(val) == "function" then
         return nil
      else
         return tostring (val)
      end
   end -- parseone

   done = done or {}

   for key, value in pairs (t) do

      if type (value) == "table" and not done [value] then
         parent[key] = parent[key] or { }       
         done [value] = true
         parse_gmcp(value, done, parent[key])
      else
         parent[key] = parseone(value) -- might be able to remove last parameter.
      end
   end -- for
end -- parse_gmcp function

function unitopia_messages(text)
if text == "Sound.Url" then
    local l_url = gmcpitem ("Sound.Url.url")
    local l_mudname = gmcpitem ("Core.Hello.name")
    Note (l_url.." | "..l_mudname)
    createLocalSoundDb (l_mudname,l_url)
elseif text == "Sound.Event" then
    local l_file = gmcpitem ("Sound.Event.file")
    local l_ret,l_err = playFromCacheOrServer (l_file)
    if l_ret then
        return true
    else
        Note (l_err)
    end -- if l_ret
else
    Note ("GMCP.text = "..text) -- unknown GMCP infos...
end -- if
end -- function unitopia_sound

]]>
</script>

</muclient>

